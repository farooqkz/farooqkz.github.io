<!doctype html><html lang=en><head><meta charset=UTF-8><title>Benchmarking Common Lisp, Rust, C and Python on ARM | Farooq's</title>
<meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Hugo 0.139.3"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content="Farooq,Farooq Karimi Zadeh,farooqkz"><link rel=icon type=image/png href=/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicon-16x16.png sizes=16x16><link rel=stylesheet type=text/css media=screen href=/css/normalize.css><link rel=stylesheet type=text/css media=screen href=/css/main.css><link rel=stylesheet type=text/css media=screen href=/css/all.css><link rel=stylesheet href=/css/katex.css crossorigin=anonymous><script defer src=/js/katex.js integrity=sha384-HELAAZU8xvHgfT/8z4Mhmu+E2z3oBrMEuywaMh/CEd5uTZIDSct7TEaX+S43+dOi crossorigin=anonymous></script><script defer src=/js/auto-render.js integrity=sha384-0QrOZ8WIARJUoT5pH7Iuzi7iq0mXUXLF9yj5ZvYxTkMRv1zcaPQiOQ9ksHYbKw7M crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="http://far.chickenkiller.com/computer/benchmarking-common-lisp-rust-c-and-python-on-arm/"><meta property="og:site_name" content="Farooq's"><meta property="og:title" content="Benchmarking Common Lisp, Rust,  C and Python on ARM"><meta property="og:description" content="I have previously benchmarked C++ against Common Lisp and the result was that unlike the common belief about Lisp, it can have performance which is almost as fast as C++. After that I did another benchmark for computing fibonnaci series using Rust, Common Lisp, C and Python. But both of these benchmarks were done on x86_64. In this benchmark, I’m using the same codes from the last benchmark but run them on an ARM device instead. Unfortunately, my device is old and not ARM64 but still it can be of interest."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="computer"><meta property="article:published_time" content="2022-11-16T14:19:59+03:30"><meta property="article:modified_time" content="2022-11-16T14:19:59+03:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Benchmarking Common Lisp, Rust,  C and Python on ARM"><meta name=twitter:description content="I have previously benchmarked C++ against Common Lisp and the result was that unlike the common belief about Lisp, it can have performance which is almost as fast as C++. After that I did another benchmark for computing fibonnaci series using Rust, Common Lisp, C and Python. But both of these benchmarks were done on x86_64. In this benchmark, I’m using the same codes from the last benchmark but run them on an ARM device instead. Unfortunately, my device is old and not ARM64 but still it can be of interest."><meta itemprop=name content="Benchmarking Common Lisp, Rust,  C and Python on ARM"><meta itemprop=description content="I have previously benchmarked C++ against Common Lisp and the result was that unlike the common belief about Lisp, it can have performance which is almost as fast as C++. After that I did another benchmark for computing fibonnaci series using Rust, Common Lisp, C and Python. But both of these benchmarks were done on x86_64. In this benchmark, I’m using the same codes from the last benchmark but run them on an ARM device instead. Unfortunately, my device is old and not ARM64 but still it can be of interest."><meta itemprop=datePublished content="2022-11-16T14:19:59+03:30"><meta itemprop=dateModified content="2022-11-16T14:19:59+03:30"><meta itemprop=wordCount content="743"><script data-goatcounter=https://farooqkz.goatcounter.com/count>(function(){"use strict";window.goatcounter&&window.goatcounter.vars?window.goatcounter=window.goatcounter.vars:window.goatcounter=window.goatcounter||{};var e,t,n,o,i,a,r,c,l,d,u,s=document.querySelector("script[data-goatcounter]");if(s&&s.dataset.goatcounterSettings){try{o=JSON.parse(s.dataset.goatcounterSettings)}catch(e){console.error("invalid JSON in data-goatcounter-settings: "+e)}for(i in o)["no_onload","no_events","allow_local","allow_frame","path","title","referrer","event"].indexOf(i)>-1&&(window.goatcounter[i]=o[i])}e=encodeURIComponent,l=function(e){var s,o,i,t={p:e.path===void 0?goatcounter.path:e.path,r:e.referrer===void 0?goatcounter.referrer:e.referrer,t:e.title===void 0?goatcounter.title:e.title,e:!!(e.event||goatcounter.event),s:[window.screen.width,window.screen.height,window.devicePixelRatio||1],b:d(),q:location.search};return typeof t.r=="function"&&(s=t.r),typeof t.t=="function"&&(i=t.t),typeof t.p=="function"&&(o=t.p),n(t.r)&&(t.r=document.referrer),n(t.t)&&(t.t=document.title),n(t.p)&&(t.p=r()),s&&(t.r=s(t.r)),i&&(t.t=i(t.t)),o&&(t.p=o(t.p)),t},n=function(e){return e==null||typeof e=="function"},d=function(){var e=window,t=document;return e.callPhantom||e._phantom||e.phantom?150:e.__nightmare?151:t.__selenium_unwrapped||t.__webdriver_evaluate||t.__driver_evaluate?152:navigator.webdriver?153:0},u=function(t){var n,s=[];for(n in t)t[n]!==""&&t[n]!==null&&t[n]!==void 0&&t[n]!==!1&&s.push(e(n)+"="+e(t[n]));return"?"+s.join("&")},t=function(e){console&&"warn"in console&&console.warn("goatcounter: "+e)},a=function(){var e=document.querySelector("script[data-goatcounter]");return e&&e.dataset.goatcounter?e.dataset.goatcounter:goatcounter.endpoint||window.counter},r=function(){var e,t=location,n=document.querySelector('link[rel="canonical"][href]');return n&&(e=document.createElement("a"),e.href=n.href,e.hostname.replace(/^www\./,"")===location.hostname.replace(/^www\./,"")&&(t=e)),t.pathname+t.search||"/"},c=function(e){document.body===null?document.addEventListener("DOMContentLoaded",function(){e()},!1):e()},goatcounter.filter=function(){return"visibilityState"in document&&document.visibilityState==="prerender"?"visibilityState":!goatcounter.allow_frame&&location!==parent.location?"frame":!goatcounter.allow_local&&location.hostname.match(/(localhost$|^127\.|^10\.|^172\.(1[6-9]|2[0-9]|3[0-1])\.|^192\.168\.|^0\.0\.0\.0$)/)?"localhost":!goatcounter.allow_local&&location.protocol==="file:"?"localfile":!!(localStorage&&localStorage.getItem("skipgc")==="t")&&"disabled with #toggle-goatcounter"},window.goatcounter.url=function(e){var s,n=l(e||{});if(n.p===null)return;return n.rnd=Math.random().toString(36).substr(2,5),s=a(),s?s+u(n):t("no endpoint found")},window.goatcounter.count=function(e){var n,s,i,o=goatcounter.filter();if(o)return t("not counting because of: "+o);if(s=goatcounter.url(e),!s)return t("not counting because path callback returned null");navigator.sendBeacon(s)||(n=document.createElement("img"),n.src=s,n.style.position="absolute",n.style.bottom="0px",n.style.width="1px",n.style.height="1px",n.loading="eager",n.setAttribute("alt",""),n.setAttribute("aria-hidden","true"),i=function(){n&&n.parentNode&&n.parentNode.removeChild(n)},n.addEventListener("load",i,!1),document.body.appendChild(n))},window.goatcounter.get_query=function(e){for(var n=location.search.substr(1).split("&"),t=0;t<n.length;t++)if(n[t].toLowerCase().indexOf(e.toLowerCase()+"=")===0)return n[t].substr(e.length+1)},window.goatcounter.bind_events=function(){if(!document.querySelectorAll)return;var e=function(e){return function(){goatcounter.count({event:!0,path:e.dataset.goatcounterClick||e.name||e.id||"",title:e.dataset.goatcounterTitle||e.title||(e.innerHTML||"").substr(0,200)||"",referrer:e.dataset.goatcounterReferrer||e.dataset.goatcounterReferral||""})}};Array.prototype.slice.call(document.querySelectorAll("*[data-goatcounter-click]")).forEach(function(t){if(t.dataset.goatcounterBound)return;var n=e(t);t.addEventListener("click",n,!1),t.addEventListener("auxclick",n,!1),t.dataset.goatcounterBound="true"})},window.goatcounter.visit_count=function(n){c(function(){n=n||{},n.type=n.type||"html",n.append=n.append||"body",n.path=n.path||r(),n.attr=n.attr||{width:"200",height:n.no_branding?"60":"80"},n.attr.src=a()+"er/"+e(n.path)+"."+e(n.type)+"?",n.no_branding&&(n.attr.src+="&no_branding=1"),n.style&&(n.attr.src+="&style="+e(n.style)),n.start&&(n.attr.src+="&start="+e(n.start)),n.end&&(n.attr.src+="&end="+e(n.end));var s,o,c,i={png:"img",svg:"img",html:"iframe"}[n.type];if(!i)return t("visit_count: unknown type: "+n.type);n.type==="html"&&(n.attr.frameborder="0",n.attr.scrolling="no"),s=document.createElement(i);for(c in n.attr)s.setAttribute(c,n.attr[c]);if(o=document.querySelector(n.append),!o)return t("visit_count: append not found: "+n.append);o.appendChild(s)})},location.hash==="#toggle-goatcounter"&&(localStorage.getItem("skipgc")==="t"?(localStorage.removeItem("skipgc","t"),alert("GoatCounter tracking is now ENABLED in this browser.")):(localStorage.setItem("skipgc","t"),alert("GoatCounter tracking is now DISABLED in this browser until "+location+" is loaded again."))),goatcounter.no_onload||c(function(){if(!("visibilityState"in document)||document.visibilityState==="visible")goatcounter.count();else{var e=function(){if(document.visibilityState!=="visible")return;document.removeEventListener("visibilitychange",e),goatcounter.count()};document.addEventListener("visibilitychange",e)}goatcounter.no_events||goatcounter.bind_events()})})()</script></head><body><header><div id=avatar><a href=http://far.chickenkiller.com/><img src=/mylogo0.png alt="Farooq's"></a></div><div id=titletext><h2 id=titleonly><a href=http://far.chickenkiller.com/>Farooq's</a></h2></div><div id=title-social><div id=social><nav><ul><li><a href=/index.xml rel=me aria-label=RSS><span title=RSS class="icons fas fa-rss" aria-hidden=true></span></a></li><li><a href=https://github.com/farooqkz rel=me aria-label=Github><span title=Github class="icons fab fa-github" aria-hidden=true></span></a></li><li><a href=https://blackrock.city/@farooqkz rel=me aria-label=Mastodon><span title=Mastodon class="icons fab fa-mastodon" aria-hidden=true></span></a></li><li><button id=dark-mode aria-label="Switch Dark Mode"><span title="Switch Dark Mode" class="icons fas fa-moon" aria-hidden=true></span></button></li></ul></nav></div></div><div id=mainmenu><nav><ul><li><a href=/>Home</a></li><li><a href=/math>Math</a></li><li><a href=/computer>Computing</a></li><li><a href=/religion>Religion</a></li><li><a href=/other>Other</a></li><li><a href=/_pages/about-me>About me</a></li></ul></nav></div></header><main><div class=post><article><div class=post-header><div class=meta><div class=date><span class=day>16</span>
<span class=rest>Nov 2022</span></div></div><div class=matter><h1 class=title>Benchmarking Common Lisp, Rust, C and Python on ARM</h1><p class=post-meta><span class=post-meta></span></p></div></div><div class=markdown><p>I have previously benchmarked <a href=/computer/cpp-vs-common-lisp-performance/>C++ against Common Lisp</a> and the result was that unlike the common belief about Lisp, it can have performance which is almost as fast as C++. After that I did another benchmark for <a href=/computer/py-c-rust-cl-benchmark/>computing fibonnaci series using Rust, Common Lisp, C and Python</a>. But both of these benchmarks were done on <strong>x86_64</strong>. In this benchmark, I&rsquo;m using the same codes from the last benchmark but run them on an ARM device instead. Unfortunately, my device is old and not ARM64 but still it can be of interest.</p><p>At the time of writing this paragraph, I haven&rsquo;t done any benchmark, yet. Nevertheless, I think the results from compiled languages should be more interesting. Because this benchmark shows how much these compilers are optimized for ARM. As for Rust, C and Common Lisp, they are directly compiled to machine&rsquo;s native code. Regarding Common Lisp, this is true if we use something which does so. Because the language itself doesn&rsquo;t require to be even compiled and it is up to the implemention to compile Common Lisp code or interpret it. Or that if it&rsquo;s compiled, it is compiled to native code or some immediate language or that it requires a VM or not.</p><p>For Rust, there is just one usable compiler which I am aware of. But for C and Common Lisp, there are more than one compiler which are both mature and compile to native code. So it would be useful if more than a single compiler is used.</p><p><figure><img src=/farooq-nanopi-neo-specs.png alt="Farooq&rsquo;s NanoPi NEO specs"></figure></p><p>As for C, I use clang and gcc which are available in Debian repositories. As for CL, one choice is definitely SBCL which is very famous for it&rsquo;s performance and that it compiles to native code. But as I want to test with other CL implementations as well, I have to choose at least one other which compiles to native code, as well.</p><p>Looking at the table on <a href=https://www.cliki.net/Common+Lisp+implementation target=_blank>this page on CLiki</a>, there is another choice: CCL. SBCL can be found in Debian repositories and as for CCL, a compiled Linux binary for ARM can be found in Github releases page.</p><h2 id=common-lisp-untyped>Common Lisp untyped</h2><h3 id=ccl>CCL</h3><pre tabindex=0><code>minetest:~:% time ./armcl --load fibo-safe.lisp
102334155
./armcl --load fibo-safe.lisp  7.39s user 0.04s system 100% cpu 7.420 total
</code></pre><h3 id=sbcl>SBCL</h3><pre tabindex=0><code>minetest:~:% time sbcl --script ./fibo-safe.lisp
102334155sbcl --script ./fibo-safe.lisp  72.11s user 0.05s system 99% cpu 1:12.16 total
</code></pre><p>It is very surprising that SBCL is this bad on ARM!</p><h2 id=common-lisp-typed-with-no-safety>Common Lisp typed with no safety</h2><h3 id=ccl-1>CCL</h3><pre tabindex=0><code>minetest:~:% time ./armcl --load fibo-unsafe.lisp
102334155
./armcl --load fibo-unsafe.lisp  5.05s user 0.04s system 100% cpu 5.086 total
</code></pre><h3 id=sbcl-1>SBCL</h3><pre tabindex=0><code>minetest:~:% time sbcl --script ./fibo-unsafe.lisp 
102334155sbcl --script ./fibo-unsafe.lisp  14.06s user 0.07s system 85% cpu 16.456 total
</code></pre><h2 id=rust>Rust</h2><pre tabindex=0><code>minetest:~:% time ./fibo
102334155
./fibo  1.50s user 0.00s system 99% cpu 1.504 total
</code></pre><h2 id=python>Python</h2><h3 id=pypy-37>Pypy 3.7</h3><pre tabindex=0><code>minetest:~:% time pypy3 fibo.py  
102334155
pypy3 fibo.py  19.88s user 0.22s system 98% cpu 20.315 total
</code></pre><h3 id=cpython-39>CPython 3.9</h3><pre tabindex=0><code>minetest:~:% time python3 fibo.py
102334155
python3 fibo.py  287.57s user 0.04s system 100% cpu 4:47.61 total
</code></pre><p>Impressive! Isn&rsquo;t it?</p><h2 id=c>C</h2><h3 id=gcc>GCC</h3><pre tabindex=0><code>minetest:~:% gcc -O2 fibo.c
minetest:~:% time ./a.out
102334155./a.out  1.63s user 0.01s system 99% cpu 1.639 total
</code></pre><h3 id=clang>clang</h3><pre tabindex=0><code>minetest:~:% clang -O2 fibo.c
minetest:~:% time ./a.out 
102334155./a.out  1.33s user 0.00s system 99% cpu 1.333 total
</code></pre><h2 id=summary-and-conclusion>Summary and conclusion</h2><p>From fastest to slowest:</p><ul><li>C with clang: <strong>1.33s</strong></li><li>Rust: <strong>1.50s</strong></li><li>C with gcc: <strong>1.64s</strong></li><li>CL typed CCL: <strong>5.09s</strong></li><li>CL untyped CCL: <strong>7.42s</strong></li><li>CL typed SBCL: <strong>16.46s</strong></li><li>Python with pypy: <strong>20.32s</strong></li><li>CL untyped SBCL: <strong>72.16s</strong></li><li>Python with CPython: <strong>287.61s</strong></li></ul><p>gcc is older than clang so it is not surprising that it outperforms clang on x86. But we see that on ARM the story is different.</p><p>Among Lispers, SBCL is known for high performance. In my previous benchmarks on x86, we saw that if we use static typing and tell
the compiler to optimize for speed only, performance of Lisp can be compared to C. However it seems that SBCL hasn&rsquo;t been optimized much for
ARM.</p><p>A reasonable concern is that the SBCL from Debian repositories has such a problem. The SBCL I have is <code>2.1.1</code> while <a href=http://www.sbcl.org/platform-table.html target=_blank>the platform table on SBCL website</a> says the latest version for ARMhf is <code>1.4.11</code>.</p><p>I&rsquo;ve tried the binary from SBCL website for my ARM device and the results were interesting: <strong>127s</strong> for untyped code and <strong>14s</strong> for the typed one!</p><p>Note that for all these languages, the Fibonnaci series is computed recursively. So this benchmark could <em>only</em> show which one does the recursion better than the others. Another benchmark for testing arithmetic would be interesting, too.</p><script type=text/javascript src=/cactus.js></script><link rel=stylesheet href=/style.css type=text/css><div id=comment-section></div><script>window.onload=()=>initComments({node:document.getElementById("comment-section"),defaultHomeserverUrl:"https://matrix.cactus.chat:8448",serverName:"cactus.chat",siteName:"far.chickenkiller.com",commentSectionId:"benchmarking-common-lisp-rust-c-and-python-on-arm.md"})</script></div></div></article></div></main><footer>(C) Some rights are reserved under CC-BY-SA 4.0 for Farooq Karimi Zadeh</footer><script src=/js/dark-mode.js></script></body></html>